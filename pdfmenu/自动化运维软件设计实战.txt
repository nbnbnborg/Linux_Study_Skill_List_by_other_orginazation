第1章 什么是自动化运维  1
1.1 硬件运维和软件运维  1
1.1.1 小故事之一――电脑专家  1
1.1.2 小故事之二――你居然不会修电脑  2
1.1.3 硬件运维与软件运维  2
1.2 软件运维的主要问题  3
1.2.1 设备数量多  3
1.2.2 系统异构性大  3
1.2.3 虚拟化的成熟带来更大的困难  4
1.3 运维常用工具  4
1.3.1 Puppet  6
1.3.2 SaltStack  6
1.3.3 Ansible  7
1.4 自动化运维  7
1.5 小结  9
第2章 集中化运维利器――Ansible  11
2.1 环境准备  11
2.2 安装Ansible  12
2.2.1 使用CentOS的EPEL源进行安装  12
2.2.2 使用Easy_Install安装Ansible  14
2.3 Ansible基础  14
2.3.1 资产配置  14
2.3.2 执行命令  17
2.3.3 指定目标主机  18
2.3.4 常用命令示例  19
2.4 Ansible常用模块  21
2.4.1 文件管理模块  21
2.4.2 命令执行模块  25
2.4.3 网络相关模块  28
2.4.4 源码管理模块  30
2.4.5 包管理模块  32
2.4.6 系统管理模块  33
2.5 PlayBook  37
2.5.1 PlayBook简介  38
2.5.2 Include语法  41
2.5.3 变量  41
2.5.4 条件  43
2.5.5 循环  44
2.5.6 PlayBook使用实例――集中化日常巡检  46
2.6 使用Ansible的API  49
2.7 小结  50
2.7.1 Ansible的优点  50
2.7.2 Ansible的缺点  51
第3章 集中化运维利器――Puppet  52
3.1 Puppet与Ansible  52
3.2 Puppet基础  56
3.2.1 安装Puppet  57
3.2.2 Puppet主要配置文件  58
3.2.3 颁发证书  61
3.2.4 第一个Puppet示例  62
3.3 Puppet的常用资源  64
3.3.1 定时任务――cron  64
3.3.2 命令执行――exec  65
3.3.3 文件管理――file  67
3.3.4 包管理――packag  69
3.3.5 服务管理――service  70
3.4 Puppet语法基础  71
3.4.1 资源  72
3.4.2 类  73
3.4.3 变量  73
3.5 小结  76
3.5.1 Puppet的优点  76
3.5.2 Puppet的缺点  76
第4章 集中化运维利器――SaltStack  77
4.1 SaltStack、Puppet、Ansible  77
4.2 Agent模式――SaltSSH  79
4.3 SaltStack的基本组成  81
4.4 Salt State概述  82
4.4.1 top.sls  82
4.4.2 state文件  83
4.4.3 配置主机  83
4.4.4 SaltState之Requires  84
4.4.5 Template、Extends、Includes  85
4.5 主服务器模式运行  88
4.6 使用SaltStack的定时作业  89
4.7 实时执行命令  89
4.7.1 target  89
4.7.2 function  93
4.7.3 arguments  93
4.8 Pillar  93
4.8.1 使用Pillar  94
4.8.2 Pillar的一些操作方法  95
4.9 小结  96
4.9.1 SaltStack的优点  96
4.9.2 SaltStack的缺点  96
第5章 重复造一个轮子  97
5.1 从一个自动化运维软件说起  97
5.2 困难重重  100
5.2.1 多样的设备类型  100
5.2.2 运维设备的总量大  100
5.2.3 艰难的环境  100
5.2.4 多变的客户需求  101
5.3 轮子需要的特性  102
5.4 ActiveMQ基础  104
5.4.1 配置ActiveMQ  105
5.4.2 部署ActiveMQ  114
5.4.3 第一个ActiveMQ例子  117
5.5 Apache Karaf  123
5.5.1 OSGi简介  123
5.5.2 为什么选择Karaf  124
5.5.3 基础架构设计  124
5.5.4 启动Apache Karaf  126
5.5.5 制作第一个OSGi包  127
第6章 ActiveMQ概览  136
6.1 消息发送  136
6.1.1 TextMessage  136
6.1.2 MapMessage  138
6.1.3 BytesMessage  140
6.1.4 StreamMessage  144
6.1.5 BlobMessage  145
6.2 断线重连机制FailOver  158
6.2.1 配置FailOver  158
6.2.2 FailOver的常用参数  159
6.3 消息生命周期  160
6.3.1 为什么消息需要生命周期  160
6.3.2 使用消息超时机制  162
6.4 清空不常用的队列  163
6.5 使用JMX获取队列信息  164
6.5.1 启用ActiveMQ的JMX功能  165
6.5.2 获取ActiveMQ的队列信息  167
6.6 ActiveMQ的HA方案  173
6.6.1 配置NFS服务器  173
6.6.2 配置NFS客户端  173
6.6.3 调整消息中间件的配置文件  174
6.6.4 将Failover作为连接串  174
6.6.5 原理  175
第7章 Apache Karaf概览  176
7.1 理解Import和Export  176
7.2 Service Wraper  180
7.2.1 支持的平台  180
7.2.2 使用Service Wrapper  181
7.2.3 Karaf Wrapper的配置文件  184
7.3 使用控制台  187
7.3.1 Shell模块  187
7.3.2 OSGi模块  190
7.3.3 LOG模块  191
7.3.4 SSHD模块  192
7.4 Karaf的日志  194
7.4.1 Karaf.Out  194
7.4.2 Karaf.log  195
7.4.3 Application log4j 日志  196
7.5 Karaf子实例  197
7.5.1 使用Karaf子实例  197
7.5.2 为什么需要使用子实例  201
7.6 扩展Karaf控制台  203
7.6.1 使用Maven创建项目  204
7.6.2 编写控制台插件包  206
7.6.3 部署插件包  207
7.7 使用Web控制台  207
7.8 使用Feature――JDBC数据源  209
第8章 核心框架  213
8.1 核心层概述  213
8.2 核心框架  214
8.2.1 服务端消息处理  216
8.2.2 客户端消息处理  217
8.2.3 插件状态汇报  218
8.3 消息分发服务端  219
8.4 插件状态服务端  220
8.5 PlayBook服务端  221
8.5.1 PlayBook服务端设计目的  221
8.5.2 PlayBook设计示意图  223
8.6 结果处理服务端  226
8.6.1 结果处理服务端设计目的  226
8.6.2 结果处理服务端处理流程  226
第9章 通用插件包  228
9.1 插件包概览  228
9.2 作业调度模块――Cron4J  230
9.2.1 Cron4J基本使用方式  231
9.2.2 作业调度参数  232
9.2.3 重新调度作业  233
9.2.4 调度系统进程  233
9.3 数据访问模块――MidaoProject  234
9.3.1 为什么选择Midao  235
9.3.2 使用Midao  236
9.4 序列化模块――Gson  237
9.5 交互式命令执行模块――JavaExpect  242
9.6 小结  249
第10章 常用插件  250
10.1 文件下发插件  250
10.1.1 文件下发插件设计  250
10.1.2 使用Apache Common IO  251
10.2 文件抓取插件  254
10.2.1 文件抓取插件整体设计  254
10.2.2 文件抓取插件设计要点  256
10.3 命令执行插件  257
10.4 目录结构查询插件  258
第11章 整合Zabbix  261
11.1 编译安装Zabbix  261
11.1.1 部署MySQL  261
11.1.2 编译部署Apache+PHP  263
11.1.3 安装Zabbix  267
11.2 强大的触发规则  268
11.2.1 触发规则概览  268
11.2.2 特色的触发规则  270
11.3 Zabbix调用OSGi 运维功能  271
第12章 案例  275
